springframework
:웹 어플리케이션 틀 안에서 필요한 기능 구현 가능
(DI, AOP, MVC, JDBC 제공함)

Maven: 자바프로젝트의 빌드를 자동으로 해주는 도구
개발자가 xml에 작성하는 프로젝트 정보를 토대로
컴파일, 라이브러리를 연결 할 수 있다.

MVC

java: java파일이 위치한다.
주로 패키지로 묶어서 관리한다.
웹 애플리케이션에서 사용되는 Controller, Service, DAO 객체들이 위치한다.

webapp: 웹과 관련된 파일들(스프링 설정파일, JSP, HTML 파일 등)이 위치한다.

resources: JSP 파일을 제외한 html, css, js파일 등이 위치한다.

spring 폴더: 스프링 컨테이너를 생성하기 위한 스프링 설정파일이 위치한다.

views 폴더: View로 사용될 JSP파일이 위치한다.

pom.xml: 메인 repository에서 프로젝트에 필요한 라이브러리를 내려받기
위한 메이븐 설정 파일



웹 애플리케이션에서 사용자가 요청을 하면 가장 먼저 DispatcherServlet클래스가 사용자의 요청을 받는다.
개발자는 DispatcherServlet을 서블릿으로 등록해야 한다.
그리고 사용자의 모든 요청을 받기 위해서 서블릿 맵핑을 해줘야 한다. (경로는 '/' 로 설정)

DispatcherServlet  -> HandlerMapping(사용자의 요청에 부합하는 컨트롤러 검색)          (ModelAndView)
                       -> HandlerAdapter(사용자의 요청에 부합하는 컨트롤러의 메소드 실행 요청)  ->  Controller -> Service -> DAO -> DataBase
                       -> ViewResolver -> View(사용자 응답 브라우저)

프론트 컨트롤러(DispatcherServlet) -> 컨트롤러

HttpServletRequest
=> 요청에서 HttpServletRequest 객체가 소멸하기까지 상태정보를 유지하고자 할 때
     한번의 요청으로 실행된 페이지끼리 정보를 공유하고자 할때 
HttpServletRequest 객체의 setAttribute()로 데이터를 등록하고 요청 재 지정으로 getAttribute()로 메소드를 추출

@RequestMapping : 컨트롤러 구현 = 클라이언트의 요청을 처리할 메소드를 개발
                         : 요청 URL을 어떤 메소드가 처리할지 결정하는 것

@Controller : view를 반환하기 위해 사용한다.
1. Client는 URI 형식으로 웹 서비스에 요청을 보낸다.
2. Mapping 되는 Handler를 찾는 DispatcherServlet이 요청을 인터셉트한다. 
3. Controller가 요청을 처리한 후에 응답을 DispatcherServlet으로 반환하고 DispatcherServlet은 View를 사용자에게 반환한다.

servlet/jsp url주소: 사용자가 서버에 접속해서 서비스를 받기 위해 입력하는 주소

도메인 주소: 포트번호/경로1/경로2
servlet/jsp에서 첫번째 경로는 Context Path라고 부른다.
Context Path는하나의 서버에서 각 웹 애플리케이션을 구분하기 위해 지정되는 이름이며 
그 이후경로는 하위 경로이다.

1. HttpServletRequest
: Spring MVC에서 HttpServletRequest객체를 주입 받아 사용가능

2. WebRequest
: HttpServletRequest클래스를 확장한 클래스

3. @PathVariable
: 데이터가 요청 주소에 있을 경우 값을 주입 받을 수 있는 어노테이션

@GetMapping("/t1/{d1}/{d2}/{d3}")
public String t1(@PathVariable int d1,
	        @PathVariable int d2,
	        @PathVariable int d3) } { }

4. @RequestParam
: 지정된 변수 이름과 파라미터 이름이 같을 경우 값을 주입 받는다.

public String t1(@RequestParam(value="d1", required) int n1,


<Map으로 주입받기>
-동일한 이름으로 전달되는 2개 이상의 파라미터는 하나만 담기게 된다.

data3=30&data3=40

=>List로 주입 받아야 한다.

@ModelAttribute
: 파라미터를 객체로 주입 받을 수 있다.
*전달되는 파라미터 이름과 동일한 프로퍼티에 자동으로 주입이 된다.

=> command object(커맨드 객체)

		->handler mapping
사용자->dispatcher->controller
                        ->view resolver

model 클래스: 데이터 관리
model 객체를 주입받아 세팅하면 HttpServletRequest 객체에 담겨 jsp로 전달

viewresolver에 의해 jsp 실행됨, 응답 결과 만들어짐
viewresolver가 사용한 데이터를 request영역에 저장할 수 있다.
1. HttpServletRequest를 주입받아서
2. model 객체 주입
3. ModelandView (model 값 설정 가능 + view 이름 지정 가능)

커맨드 객체
: 클라이언트가 전달해주는 파라미터 데이터를 주입받기위해 사용하는 객체

* 커맨드 객체는 HttpServletRequest 객체에 자동으로 담기고 jsp로 전달됨

** HttpServletRequest 객체에 저장되는 이름은 클래스 이름이다.

커스텀 태그
<form: 태그명>
=> Model 객체에 들어있는 값을 form 요소에 주입시킬 수 있다.
=> 수정 페이지를 구성할 때 잘 쓰인다.

@RequestMapping
ModelAndView클래스
setViewName
addObject

public ModelAndView add(@RequestParam(value="n1")int n1,

/sub1/t3

HttpServletRequest
WebRequest
@RequestParam(value)
@PathVariable

form custom tag
<form:select path="a">

Redirect
서버가 클라이언트에게 요청할 주소를 응답결과로 전달하는 것을 의미

*Redirect는 새로운 요청이 발생하는 것!
(RequestScope)

HttpServletRequest 객체는 소멸 후 새롭게 생성되며

HttpSession 객체는 그대로 유지된다.

Forward
서버 상에서만 이동
HttpServletRequest 객체, HttpSession 객체

RequestScope
새로운 요청이 발생해 응답결과가 브라우저로 전달될 때까지
요청 정보가 담겨있는 Request객체를 사용할 수 있다.

이 사용범위를 RequestScope라고 부른다.

@Autowired => Bean을 자동으로 주입 받을 수 있다.

Spring MVC => request, session, application

*Bean을 정의할 때 request scope로 정의하면
요청이 발생할 때마다 Bean객체가 생성되면서 자동으로 주입된다.

<SessionScope>
1.브라우저당 하나씩 메모리 공간을 서버에서 할당한다.

2.Session 영역은 브라우저당 하나씩 지정되며 요청이 새롭게
발생해도 같은 메모리 공간을 사용한다

3.브라우저를 종료할 때까지 서버에서 사용할 수 있다.

